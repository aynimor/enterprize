Rust 遵循以下两个规则：

1.  由程序员自己决定每个值的生命周期
2.  在对象被释放后无法继续拥有一个指向该对象的指针（悬垂指针）

在 C 和 C++ 中遵循第一条规则，程序员可以随时 malloc 和 free 分配对象内存。但其并不保证第二条规则，语言将这个责任交由程序员负责。为了保证第二条规则，有些语言使用了垃圾回收机制来释放该内存。

Rust 通过限制程序使用指针的方式达到了以上目的。Rust 编译器通过检查悬空指针、重复释放、使用未初始化的内存等等方式来验证程序不包含影响内存安全的错误，同样的这也是 Rust 支持安全并发编程的基础。使用 Rust 精心设计的线程原语（primitive），确保你的代码正确使用内存的规则，同样也能避免数据竞争。多线程代码固有的不确定性通过互斥量、消息通道、原子值等这些专门设计的特性得以隔离，而不是以赤裸裸的内存引用存在。

### 4.1 所有权

在 Rust 中，每个值都只有一个决定其生命周期的所有者，当这个所有者被释放（dropped）时，其所有的值也会被清除，如果还有其他变量试图访问该值，编译器将会抛出错误（panic）

```rust
fn print_padovan() {
    let mut padovan: Vec<i32> = vec![1, 1, 1];    	// 分配
    for i in 3..10 {
        let next = padovan[i-3] + padovan[i-2];
        padovan.push(next);
    }
    println!("P(1..10) = {:?}", pandovan); 
}                                       			// 清除 
```

![image-20220328233043761](/img/image-20220328233043761.png)

`padovan` 指针、容量、和长度的 3 个字直接保存在 `print_padovan` 函数的栈帧中，只有向量的缓冲区分配在对上。向量由于保存其元素的缓冲区。当变量 `padovan` 在函数底部超出作用域时，程序会清除这个变量。由于向量拥有其缓冲区，因此该缓冲区也一并被清除。

Rust 的 `Box` 类型可以作为所有权的另一个例子。`Box<T>` 是一个指针，其指向存储在堆中的 T 类型的值。调用 `Box::new(v)` 会在堆上分配相应的空间，并将值 `v` 转移进去，最后返回一个指向该堆空间的 `Box`。因为 `Box` 拥有它指向的空间，所以当 `Box` 被清除时，其指向的空间也会被清除。

![image-20220407212513688](/img/image-20220407212513688.png)

```rust
{
	let point: Box<(f64, f64)> = Box::new((0.625, 0.5));
    let label: String = format!("{:?}", point);
    assert_eq!(label, "(0.625, 0.5)");
}
```

如上图所示，程序在调用 `Box::new()` 时，在堆中分配了一个空间，然后将元组转移到该内存空间，最后返回该内存空间的地址指针。由栈帧来保存 `point` 和 `label` 两个变量，然后各自引用自己拥有的堆空间。当变量被清除时，对应的堆空间的内存也将被清除。

通过树来描述所有权关系：你的所有者是你的父节点，你拥有的值是你的子节点，每个树的根节点则是某一个变量。当控制流超出了这个变量所在的作用域时，整个树都会被清除。此处的树并非搜索数据结构中的“树”，或者 HTML 文档的 DOM 树的概念，而是基于混合类型构建的一棵树，且严格遵守 Rust 的单一所有者规则，禁止任何形式的结构再连接（否则就不是纯粹的树了）。Rust 程序中的每个值都是某棵树的成员，都可以追溯到某个根变量。

对所有权树的扩展：

- 可以把值从一个所有者转移到另一个所有者，从而方便构建、重塑和销毁关系树。
- 标准库提供了基于引用计数的指针类型 `Rc` 和 `Arc`，使用它们可以在满足某些限制条件的前提下将值指定给多个所有者。
- 对一个值，可以“借用其引用”。引用是生命周期有限的非所有指针。

### 4.2 转移

在 Rust 中，对多数类型而言，给变量赋值、给函数传值或从函数返回值这样的操作不会复制值，而是转移（move）值。所谓转移，就是原来的所有者让渡这个值的所有权给目标所有者，从而变成未初始化状态。然后，由目标所有者控制这个值的生命周期。

**Python 中赋值在内存中的表现**

```python
s = ['udon', 'ramen', 'soba']
t = s
u = s
```

![image-20220407220415474](/img/image-20220407220415474.png)

`s`、`t`、`u` 分别指向列表对象 `PyListObject`，然后增加其引用计数，赋值代价较小，但维护引用计数代价较大

**C++ 中赋值在内存中的表现**

```c++
using namespace std;
vector<string> s = { "udon", "ramen", "soba" };
vector<string> t = s;
vector<string> t = s;
```

![image-20220407221334673](/img/image-20220407221334673.png)

C++ 中的赋值可能会消耗较多的内存和处理器时间，通过增加赋值代价来保证变量在内存中的所有权的清晰

**Rust 中赋值在内存中的表现**

```rust
let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
let t = s;
let u = s;
```

![image-20220407222421286](/img/image-20220407222421286.png)

`let t = s;` 将向量的 3 个头部字段从 s 转移到了 t，然后 t 就拥有了这个向量。这个向量的元素任然待在原处，字符串也没动。每个值依然只有一个所有者，只不过转了一手。此时没有引用计数需要调整。而编译器现在会认为 s 尚未初始化。

继续执行下一行初始化代码 `let u = s;` 时，会把尚未初始化的值 s 赋值给 u。Rust 对使用未初始化的值非常慎重，因此编译器拒绝执行这行代码并报出错误：

```
error[E0382]: use of moved value: `s`
...

let t = s;
	- value moved here
let u = s;
	^ value used here after move
```

Rust 赋值代价很小，仅仅是将向量头部从一个地方移到另一个地方，而且所有者始终很清晰，程序不需要引用计数或垃圾收集，就可以知道什么时候释放向量及其字符串内容。

如果需要明确使用这些值的副本，需要通过向量的 `clone` 方法得到完整的副本

```rust
let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
let t = s.clone();
let u = s.clone();
```

#### 4.2.1 更多转移操作

- 函数返回值转移
- 构建新值
- 给函数传值

#### 4.2.2 转移与控制流

如果一个变量的值已经被转移了，而且转移后始终未得到新值，那么这个变量就被认为是未初始化的。

```rust

let x = vec![10, 20];
if c {
	f(x);
} else {
    g(x);
}			// 两个分支最终只会走向一个分支，所以可以转移
h(x);		// 由于在上面 x 已经转移了，此时 x 已经是未初始化变量，不可使用


let x = vec![10, 20];
while f() {
    g(x);	// x 值在第一次迭代时就被转移了，后续就无法使用，所以被禁止使用
}

let mux x = vec![10, 20];
while f() {
    g(x);		// x 的值被转移
    x = h();	// 赋予新值
}
e(x);			// 由于每次 x 最终都能被赋予新值，所以此时 x 有值，可以使用

```

#### 4.2.3 转移与索引内容

```RUST
let mut v = Vec::new();
for i in 101 .. 106 {
    v.push(i.to_string());
}

let third = v[2];
let fifth = v[4];	
// 试图从一个向量中获取某个索引的所有权，该值是由向量在维护的，
// 如果被转移了，那向量就需要记录该值为`未初始化状态`
// Rust 不允许这样的操作
// 将会获得一个 panic
// error[E0507]: cannot move out of indexed content

// 如果只是访问元素可以通过引用
let _third = &v[2];
let _fifth = &v[4];

// 如果确实需要获取所有权可以通过以下几种方式
// 1. 取出向量最后一个值，向量长度减 1
let fifth = v.pop().unwrap();
assert_eq!(fifth, "105");

// 2. 取出指定索引的值，该位置将由向量的最后一个元素填充，如果只有一个元素，则向量将会清空
let second = v.swap_remove(1);
assert_eq(second, "102");

// 3. 使用其他值来替换要取出的值
let third = std::mem::replace(&mut v[2], "substitute".to_string());
assert_eq(second, "103");

assert_eq!(v, vec!["101", "104", "substitute"]);

// 4.
for mut s in v {
    s.push('!');
    println!("{}", s);
} // **由于向量本身对代码不可见，因此循环期间无法观察到它半空的状态**

// 5. 同类型的不同值的替换
let mut v = vec![Some(1), Some(2), Some(3)];
// 5.1
let first = std::mem::replace(&mut v[1], None).unwrap();
println!("{first}");

// 5.2 由于 Some 替换 None 过于常用，所以 Rust 提供了 take() 方法，效果和 replace 相同
for s in v.iter_mut() {
    let a = s.take();
    println!("{:?}", a);
}
assert_eq!(v, vec![None, None, None]);
```

### 4.3 Copy 类型：转移的例外

**大多数**类型在赋值时会转移所有权，而 `Copy` 类型的赋值会复制值，而非转移。赋值的源变量任然是初始化且可用的，值也跟先前一样。

标准的 `Copy` 类型包括所有机器整数和浮点数、`char` 和 `bool` 类型，以及其它几种类型。`Copy` 类型的元组（所有元素都是 `Copy` ）或固定大小的数组本身也是 `Copy` 类型。

只有可以简单地位到位复制的类型才是 `Copy` 类型。其他任何在值被清除后需要特殊处理的类型都不能是 `Copy` 类型，比如 `Vec` 需要释放元素，`File` 需要关闭文件句柄，`MutexGuard` 需要解锁互斥量。

默认情况下用户自定义的 `struct` 和 `enum` 类型不是 `Copy` 类型。可以通过在定义上方添加 `#[derive(Copy, Clone)]` 将该类型标注为 `Copy` 类型，前提条件是其所有字段都是 `Copy` 类型的，否则将会在编译时抛出异常

```rust
#[derive(Copy, Clone)]
struct Lable { number: u32 }
```

### 4.4 `Rc` 和 `Arc`：共享所有权

`Rc`（reference count） 和 `Arc`（atomic reference count：原子引用计数） 是基于引用计数的指针类型，两者的区别在于 `Arc` 可以在线程间安全共享，`Rc` 会使用更快的非线程安全的代码更新其引用计数，Rust 禁止在线程间传递 `Rc` 指针。除此之外两者完全等价。

```rust
use std::rc::Rc;

fn main() {
    let sr = "shirataki".to_string();
    let s: Rc<String> = Rc::new(sr);		// sr 的所有权被转移给 s
    let t: Rc<String> = s.clone();			// s 所指向的内存地址引用计数加一
    let u: Rc<String> = s.clone();
}
```

其内存空间中的形式类似与 `Python` 会增加堆中 `sr` 变量的引用计数，当最后一个 `Rc` 被清除后， Rust 也会清除对应的 String。`Rc` 指针拥有的值不可修改。

Rust 的内存和线程安全保证有一个前提，即不存在即共享又可修改的值。Rust 假设 `Rc` 指针引用的值通常是共享的，因此不可修改。

使用引用计数管理内存的另一个问题是，如果两个引用计数的值相互指向对方，则双方的引用计数将始终大于 0，因此两个值将永远不会被释放

Rust 在正常情况下是无法创建循环引用的，不过 Rust 提供了给不可修改的值创建可修改的能力（**内部修改能力（interior mutability）**：第九章内容）。

有时，使用**弱指针**（weak pointer）`std::rc::Weak` 取代一些链接可以避免创建 `Rc` 指针的循环。
