| 类型                                       | 说明                                                         | 值                                                           |
| ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| i8、i16、i32、i64、<br />u8、u16、u32、u64 | 给定位宽的有符号和无符号整数                                 | 42、-5i8、0x400u16、0b10010、<br />888_888_888u64、b'*'（u8 字节字面量） |
| isize、usize                               | 与机器字（32 位或 64 位）同样大<br />的有符号和无符号整数    | 137、-0b0111_0001isize、<br />0xffff_ffc0usize               |
| f32、f64                                   | 单精度、双精度 IEEE 浮点数值类型                             | 1.61803、3.14f32、6.0221e23f64                               |
| bool                                       | 布尔值                                                       | true、false                                                  |
| char                                       | Unicode 字符，32 位宽                                        | '*'、'\n'、'字'、'\x7f'、'\u{CA0}'                           |
| (char, u8, i32)                            | 元组，允许混合类型                                           | ('%', 0x7f, -1)                                              |
| ()                                         | “基元”（空）元组                                             | ()                                                           |
| struct S { x: f32, <br />y: i64 }          | 命名字段结构体                                               | S { x: 120.0, y: 64 }                                        |
| struct T(i32, char)                        | 类元组结构体                                                 | T (120, 'X')                                                 |
| struct E;                                  | 类“基元”结构体，无字段                                       | E                                                            |
| enum Attend { OnTime, <br />Late(u32) }    | 枚举，或代数数据类型                                         | Attend::Late(5)、Attend::OnTime                              |
| Box\<Attend\>                              | Box：拥有指向堆中值的指针                                    | Box::new(Attend::Late(5))                                    |
| &i32、&mut i32                             | 共享和可修改的引用：非所有权类型指针，<br />生命周期不能超过引用的值 | &s.y、&mut v                                                 |
| String                                     | UTF-8 字符串，动态分配大小                                   | "哈哈哈".to_string、<br />String::new("哈哈")                |
| &str                                       | 对 str 的引用：对 UTF-8 文本的<br />非所有权类型指针         | "哈哈哈"、&s[0..12]                                          |
| [f64; 4]、[u8; 256]                        | 数组，固定长度，元素类型都相同                               | [1.0, 2.0, 3f64]、[b' '; 256]                                |
| Vec\<f64\>                                 | 向量，可变长度，元素类型都相同                               | vec![1.0, 2.0, 3.0]                                          |
| &[u8]、&mut [u8]                           | 对切片，即数组或向量某一部分的引用，<br />包含指针和长度     | &v[10..20]、&mut a[...]                                      |
| &Any、&mut Read                            | 特性对象，对任何实现了一组<br />给定方法的值的引用           | value as &Any、<br />&mut file as &mut Read                  |
| fn(&str, usize) -> isize                   | 函数指针                                                     | i32::saaturating_add                                         |
| （闭包类型没有书面形式）                   | 闭包                                                         | \|a, b\| a * a + b * b                                       |

### 3.1 机器类型

Rust 的基础类型是一组固定宽度的数值类型（与几乎所有现代处理器直接在硬件中实现的类型对应），以及布尔类型和字符类型。

#### 3.1.1 整数类型

Rust 整数类型又分为无符号整数和有符号整数

| 类型  | 大小（位） | 有/无符号 | 范围                                                         |
| ----- | ---------- | --------- | ------------------------------------------------------------ |
| i8    | 8          | 有        | -2^7 到 (2^7)-1 （-128 到 127）                              |
| i16   | 16         | 有        | -2^15 到 (2^15)-1 （-32, 768 到 32, 767）                    |
| i32   | 32         | 有        | -2^31 到 (2^31)-1 （-2, 147, 483, 648 到 2, 147, 483, 647）  |
| i64   | 64         | 有        | -2^63 到 (2^63)-1 （-9, 223, 272, 036, 854, 775, 808 到 9, 223, 272, 036, 854, 775, 807） |
| isize | 机器字     | 有        | -2^31 到 (2^31)-1  或 -2^63 到 (2^63)-1                      |
| u8    | 8          | 无        | 0 到 (2^8)-1 （0 到 255）                                    |
| u16   | 16         | 无        | 0 到 (2^16)-1 （0 到 65, 535）                               |
| u32   | 32         | 无        | 0 到 (2^32)-1 （0 到 4, 294, 967, 295）                      |
| u64   | 64         | 无        | 0 到 (2^64)-1 （0 到 18, 446, 744, 073, 709, 551, 615）      |
| usize | 机器字     | 无        | 0 到 (2^32)-1  或 (2^64) - 1                                 |

Rust 通常使用 u8 类型表示字节值。比如，从文件或套接口读取数据拿到的是 u8 值数据流。与 C 和 C++ 不同，Rust 会将字符类型（char）与数值类型区别对待，即 char 既不是 u8 也不是 i8。

Rust 要求数组索引必须是 usize 值。另外，表示数组或向量的大小，或某些数据结构中元素数量的值通常也是 usize 类型。

尽管数值类型和 char 类型不一样，但 Rust 还是提供了**字节字面量**（byte literal），即用类字符子字面量表示的 u8 值：b'X' 表示 ASCII 编码的字符X，它是一个 u8 值。注意：字节字面量中只能出现 ASCII 编码的字符。

**需要特殊处理的 ASCII 字节字面量**

| 字符       | 字符字面量 | 对等的数值 |
| ---------- | ---------- | ---------- |
| 单引号 `'` | b'\\''     | 39u8       |
| 反斜杠 `\` | b'\\\\'    | 92u8       |
| 换行       | b'\\n'     | 10u8       |
| 回车       | b'\\r'     | 13u8       |
| 制表符     | b'\\t'     | 9u8        |

Rust 不支持数值类型的隐式转换，但是可以使用 `as` 操作符实现整数类型之间的转换

``` rust
assert_eq!(10i8 as u16, 10u16);	// 在范围内
assert_eq!(10i8 as u16, 10u16);	// 在范围内

assert_eq!(-1i16 as i32, -1i32);
assert_eq!(65535u16 as i32, 65535i32);

// 超出目的类型范围的转换会得到原始值对 2 的 N 次方取模后的值，
// 其中 N 是目的类型的位宽。这种情况也被称为“截短”
assert_eq!(1000i16 as u8, 232u8);
assert_eq!(65535u32 as i16, -1i16);
```

#### 3.1.2 浮点类型

| 类型 | 精度                          | 范围                                 |
| ---- | ----------------------------- | ------------------------------------ |
| f32  | IEEE 单精度（至少 6 位小数）  | 约 -3.4 * (10^38) 到 3.4 * (10^38)   |
| f64  | IEEE 双精度（至少 15 位小数） | 约 -1.8 * (10^308) 到 1.8 * (10^308) |

一个浮点字面量的通用形式：`31415.926e-4f64`，整数部分：`31415`，小数部分：`.926`，指数部分：`e-4`，类型后缀：`f64`，除了整数部分其他都是可选的，但小数部分、指数部分和类型后缀至少要存在一个，以将其和整数字面量区分开来。Rust 默认为 f64 双精度。

浮点类型一样支持 `as` 操作符的显示转换：`assert_eq!(444f32 as f64, 444f64)`

#### 3.1.3 布尔类型

Rust 的布尔类型有两个值：true 和 false。== 和 < 等比较操作符都产生布尔值，比如 3 < 5 是 true。

``` rust
assert_eq!(false as i32, 0);
assert_eq!(true as i32, 1);
// 不能反向转换 0 as false，这是错误的使用方式必须使用 x != 0
```

Rust 非常严格的在 if 和 while 等流程控制结构中和短路逻辑操作 && 和 || 中，严格要求条件必须是 `bool` 表达式，例如 `if x { ... }` 是不正确的，必须使用 `if x != 0 { ... }`

#### 3.1.4 字符类型

Rust 的字符类型 char 以 32 位值的形式表示单个 Unicode 字符。字符字面量就是使用单引号 `'` 引起来的字符，比如 '8' 或 '字'，字节字面量中需要特殊处理的字符，在字符字面量中依然适用。

### 3.2 元组

元组 （tuple）中的每个元素都可以是不同的类型：`("Brazil", 1985, 'B', 1.0, true)`，元组只允许使用常量作为索引，比如 `t.4`，不能通过 `t.i` 或 `t[i]` 的方式取得第 `i` 个元素。

在 `Rust` 中函数经常通过元组返回多个值：`fn split_at(&self, mid: usize) -> (&str, &str)`，调用方法时使用模式匹配分别赋予不同的变量：`let (a, b) = "test str".split_at(4);`

零元组 `()` 也是一个常用的元组类型，通常称作**基元类型**，其作用是：当不存在有意义的值，而上下文又要求某种类型是，就可以使用 `()`。

当元组中只有一个元素时，必须在后面添加一个 `,` 否则无法区分是否为元组：`(12i32,)`

### 3.3 指针类型

在 Rust 程序中的值需要指向其他值时，必须显示的使用指针类型。在安全 Rust 程序中使用指针会受到限制以消除未定义行为。

#### 3.3.1 引用

一个 `&String` （引用字符串）类型的值就是一个对 `String` 值的引用，其他也是类似，`&i32` 引用 `i32` 的值。

引用可以简单理解为 Rust 的基本指针类型。引用可以指向任何地方的任何值，无论栈或堆。表达式 `&x` 会产生一个对 `x` 的引用，用 Rust 的话说就是，它借用了一个对 `x` 的引用。而拿到一个 **引用** `r`，表达式 `*r` 引用的则是 `r` 指向的值。

引用同样分为可变和不可变的：

-  `&T` 为不可变引用，类比于 C 中的 `const T*`;
- `&mut T` 为可变引用，类比于 C 中的 `T*` 

Rust 会追踪引用的所有权和生命周期，所以 Rust 的**安全代码**（当然也可以手动指定不安全代码，后面会提到）不存在悬空指针、重复释放和指针失效等错误。

#### 3.3.2 Box

使用 `Box` 可以在堆中分配值。

``` rust
let t = (12, "eggs");
let b = Box::new(t); 	// 在堆中分配一个元组，Box 的类型为 Box<i32, &str>
// 当 b 超出作用域时后，内存会自动释放（Drop），除非 b 的所有权被转移给其他变量
```

#### 3.3.3 原始指针

原始指针分为 `*mut T` 和 `*const T`。含义基本与 C 中的指针相同。解引用原始指针一般只能在 Rust 中的 `unsafe` 代码块中进行，这被称为 **不安全代码**，21 章会详细讨论。

### 3.4 数组、向量和切片

- 数组每个值的类型必须相同，表示为：`[T; N]`（一个有 N 个值构成的数组，每个值的类型都是 T），不可更改长度
- 向量每个值得类型必须相同，表示为：`Vec<T>`（T 类型的向量），可动态扩展长度
- 类型 `&[T] 和 &mut [T]` 叫作 **T 类型的共享切片**和**T 类型的可修改切片**，是其他值（如数组或向量）中部分元组序列的引用，可修改切片可以读写切片，但不能共享；共享切片可以共享，但不能修改元素

3 种类型都可以通过有效范围内的索引访问其中的元素，超出索引范围的访问会导致 `panic` （类似于 raise）

#### 3.4.1 数组

数组有几种写法：

```rust
let x: [u32; 6] = [1, 2, 4, 8, 16, 32];
let y = ["Animalia", "Arthropoda", "Insecta"]

assert_eq!(x[3], 8);
assert_eq!(y.len(), 3);

let long_size_list = [0; 10000];	// 会生成长度为 10000 的数组，数组中的所有值都为 0，[V; N]
let buffer = [0u8; 1024];			// 用于表示 1024 字节的缓冲区，零字节填充
```

Rust 没有表示未初始化数组的写法。

初始化数组中 `[V; N]` 的写法中，`N` 也是数组类型自身的一部分，必须直接写在语句中，如果使用变量赋值会导致错误：

- attempt to use a non-constant value in a constant non-constant value

如果需要一个运行时可变长度的数组，那就用向量：`Vec`

#### 3.4.2 向量

向量 `Vec<T>` 是分配在堆上的类型 `T` 的可缩放序列。

```rust
// 创建方式 1
let mut v1: Vec<i32> = Vec::new();
// 需要动态修改长度，则变量必须声明为 mut 可变变量
v1.push(1);
v1.push(2);
v1.push(3);

// 创建方式 2
let mut v2: Vec<i32> = vec![1, 2];
v2.push(3);
assert_eq!(v1, v2);

// 创建方式 3
// 此种方式创建向量必须指明类型，其他方式如果不指定时会自动推导
let v3: Vec<i32> = (0..5).collect();
assert_eq!(v3, [0, 1, 2, 3, 4]);

// 创建方式 4
// 如提前知道向量长度
let v4: Vec<i32> = Vec::with_capacity(2);
v4.push(1);
v4.push(2);
assert_eq!(v, vec![1, 2]);
assert_eq!(v.len(), 2);
assert_eq!(v.capacity(), 2);
```

一个 `Vec<T>` 包含 3 个值：对分配在对上的用于保存元素的缓冲区的引用、该缓冲区可以存储的元素个数（容量），以及当前实际存储的元素个数（长度）。当缓冲区达到容量上限后，会先分配一个更大的缓冲区，然后复制内容到新的缓冲区，在基于新的缓冲区更新向量的指针和容器，最后释放旧的缓冲区。

```rust
// 插入操作
let mut v: Vec<i32> = vec![1, 2];

// insert( index, value )，可以在任意位置插入元素，索引长度不能超过当前向量长度：panic insertion index (is 9) should be <= len (is 5)
v.insert(2, 3);
v.insert(0, 0);

// 删除操作
// remove( index )，索引大小同样不能超过长度，同时会返回被删除元素的值
let i:i32 = v.remove(1)

// pop()，尝试删除数组最后一个元素，并返回 Option 枚举包含的值
let d: Option<i32> = v.pop();
match d {
    Some(i) => println!("{}", i),
    None => println!("Vec `v` have not value"),
}


```

#### 3.4.3 逐个元素的构建向量

向量缓冲区增大遵循 1、2、4、8、......、2^n

#### 3.4.4 *切片

切片（slice），写作不指定长度的 `[T]`，表示数组或向量的一个范围。由于切片可以是任意长度，因此不能保存到变量中，也不能作为函数参数传递。切片永远只能按引用传递。

切片的引用是一个胖指针（fat pointer），即一个双字宽的值，保存着指向切片的一个元素的指针和切片中元素的个数。

Rust 会自动把向量和数组的引用转换为指向数据的切片引用。是对多个值的非所有型指针（普通引用则是对单个值的非所有型指针）。

![image-20220327141451492](/img/image-20220327141451492.png)

``` rust
let v: Vec<i32> = vec![1, 2, 3, 4, 5, 6, 7];
let a: [i32; 5] = [1, 2, 3, 4, 5];

let sv: &[i32] = &v;
let sa: &[i32] = &a;
```



Rust 中很多针对数组或向量的操作实际上使用的是切片类型的方法，比如 `sort` 和 `reverse`，都是定义在切片类型上的。

### 3.5 字符串类型

#### 3.5.1 字符串字面量

```rust
let speech = "\"Ouch!\" said the well.\n";
```

字符串字面量由双引号包围，若其中需要使用 `"`，则需要转移符号 `\"`，单引号无需转义。

```rust
// 一些字符串的使用方式
println!("In the room the women come and go,
    	Singing of Mount Abora");

// 在换行时使用 \ 会使编译器忽略 \ 后的所有空格字符
println!("It was a bright, cold day in april, and \
    there were four of us-\
    more or less.");

// 原始字符串（raw string）语法，以 r 作为标记，会使编译器忽略转义
let default_win_install_path = r"C:\Program Files\Gorillas";
let pattern = Regex::new(r"\d+(\.\d+)*");


println!(r###"
	This raw string started with 'r###'.
    Therefore it does not end until we readch a quote mark('"')
    followed immediately by three pound signs ('###'):
"###);
```

#### 3.5.2 字节字符串

字节字符串不能包含任意 Unicode 字符，只能是 ASCII 和 \xHH 转义序列

```rust
let method: &[u8; 3] = b"GET";
asssert_eq!(method, &[b'G', b'E', b'T']);

let raw_method1: &[u8; 3] = br"GET
	SOME";
// 由于 GET 末尾 \n 和 SOME 开头 \t 包含两个字节加上原有的7个字节所以共 9 个字节
let raw_method2: &[u8, 9] = br###"GET
	SOME"###;
```

#### 3.5.3 字符串在内存中的表示

Rust 中字符串在内存中使用 UTF-8 可变宽度编码存储。ASCII 字符用一个字节存储，其他字符占用多个字节。

```rust
let noodles: String = "noodles".to_string();
let oodles: &str = &noodles[1..];
let poodles: &str = "ಠ_ಠ"
```

![image-20220327145255304](/img/image-20220327145255304.png)

String 标准库使用 `Vec<u8>` 实现，能够动态调整大小 。

&str（字符串切片）对其他 UTF-8 文本的引用：它“借用”了这些文本，&str 也是一个胖指针，包含实际数据的地址即长度。

字符串字面量是一个预分配文本引用的 &str，通常存储在只读内存中。&str 类型是无法修改的，无论是字符串切片还是字符串字面量。

#### 3.5.4 字符串

&str 类似于 &[T]，就是一个指向某些数据的胖指针。String 则类似 Vec\<T\>

|                                       | Vec\<T\>          | String          |
| ------------------------------------- | ----------------- | --------------- |
| 自动释放内存                          | 是                | 是              |
| 可扩展                                | 是                | 是              |
| ::new() 和 ::with_capacity() 静态方法 | 是                | 是              |
| .reverse() 和 .capacity() 方法        | 是                | 是              |
| .push() 和 .pop() 方法                | 是                | 是              |
| 范围语法 v[start..stop]               | 是，返回 &[T]     | 是，返回 &str   |
| 自动转换                              | &Vec\<T\> 到 &[T] | &String 到 &str |
| 继承方法                              | 继承自 &[T]       | 继承自 &str     |

```rust
// 创建方式
let first = String::new("too many pets");
let error_message = "too many pets".to_string();
assert_eq!(first, error_message);

let coor = format!("{}-{}", 123, 456);
assert_eq!(String::new("123-456"), coor);

let bits = vec!["veni", "vidi", "vici"];
assert_eq!(bits.concat(), "venividivici");
assert_eq!(bits.join(", ", "veni, vidi, vici");
```

#### 3.5.5 使用字符串

```rust
assert!("ONE".to_lowercase() == "one");
assert!("one".to_uppercase() == "ONE");
assert!("one".contains("ne"));
assert!("one".replace("n", "-") == "o-e");
assert!("   one   ".trim() == "one");
assert!("one".start_with("o"));
```
