## 第一章 为什么是 Rust

编程语言发展至今任然有两个问题没有解决：

1. 写出内存安全的代码并不容易
2. 编写多线程代码十分困难
   Rust 的出现似乎为解决以上两个问题提供了一个可能性。

Rust 遵循由 C++ 之父 Bjarne Stroustrup 提出的理念：

- 总的来说，C++ 实现遵循零开销的原则：不用的，不必为之付出代价；要用的，也不会有代码比他更好。

而 Rust 基于其特有的特性：所有权（ownership）、转移（move）和借用（borrow）机制，及其编译时检查的设计机制，即实现了零开销的能力，又解决了内存安全及多线程编程问题。所有权机制划定了每个变量的`生命周期`[注1]，从而无需垃圾回收机制。转移把值从所有者转移给另一个所有者，有效防止了内存由于不可预测的原因而被多次重复修改的问题；而借用则是在遵循所有权和转移的基础上，将值转移给另一个变量，从而可使其修改内存值同时又不影响其所有权[注2]。

> 注1：生命周期指一个变量从被声明使用到被销毁的整个代码周期
> 注2：第四章和第五章有详细论述

所有权规则同时也是 Rust 并发模型的基础，其保证了 Rust 的互斥量（Mutex）在代码编译时就能被有效解决。Rust 能在编译时防止数据竞争问题。

Rust 并非面向对象的编程语言同时也不是函数式编程语言，只是在一定程度上具有两者的特性。

### 类型安全

定义：如果一个程序写得不可能在执行时导致未定义行为，那么就成这个程序为定义良好的（well defined）。如果一种语言的安全检查可以保证所有程序都定义良好，那么就称这种语言是类型安全的。Rust 是类型安全的语言。

#### 未定义行为

C 编程语言在 1999 年标准（C99）中对未定义行为的定义如下：
    **由于使用不可移植或错误的程序构造，或者使用错误的数据导致的行为，本国际标准对此不作要求**

``` C
int main(int argc, char **argv) {
    unsigned long a[1];
    a[3] = 0x7ffff7b36cebUL;
    return 0;
}
```

根据 C99 标准元素超出了数组 a 的边界，所以他的行为是未定义的。相对而言 Python 是类型安全的，Python 花费处理器时间来检查和处理数组索引越界的操作，Python 会抛出异常，而这不是未定义行为。
类型安全与语言是在编译时检查还是运行时检查类型是无关的。